# pceudo

Захотелось мне более читаемого и интуитивного ассемблера.
Сейчас более менее работает версия под stm8s (наполняю библиотеку макросов) собственно транслятор уже знает и stm8l и avr - но под них нет никаких заголовков - вопрос времени.

В этом языке псевдо-ассемблера есть очень мало команд, однако каждая команда превращается ровно в одну ассемблерную инструкцию.
Нельзя в одной команде сочетать несколько действий. Команды разделяются символами ";" или "\n". Можно писать несколько команд в одной строке через ';'.
Нельзя переносить полкоманды на другую строку (например if на одной строке а метка на другой).

Операции:

КОМЕНТАРИЙ				// текст, можно ставить как в начале так и после любой команды кроме 'define' препроцессора

ПРИСВАИВАНИЕ			X=Y

СЛОЖЕНИЕ				X+=Y
ВЫЧИТАНИЕ				X-=Y
УМНОЖЕНИЕ				X*=Y		( в версии stm8 реально доступны только x*=a или y*=a)
ДЕЛЕНИЕ					X/=Y		( в версии stm8 реально доступны только x/=a, y/=a или x/=y - последний меняет и x и y - в y возвращает остаток от деления )
ИНВЕРСИЯ ЗНАКА			-X
ПРОВЕРКА ФЛАГОВ			?X
СРАВНЕНИЕ				X?Y		    ( в версии stm8 реально доступны только a?... x?... y?...)
ИНКРЕМЕНТ				X++ или ++X (два варианта полностью эквивалентны)
ДЕКРЕМЕНТ				X-- или --X (два варианта полностью эквивалентны)

ЛОГИЧЕСКОЕ AND			X&=Y
ЛОГИЧЕСКОЕ OR			X|=Y
ЛОГИЧЕСКОЕ XOR			X^=Y
ЛОГИЧЕСКОЕ NOT			!X
ЛОГИЧЕСКОЕ СРАВНЕНИЕ	X&?Y		( в версии stm8 реально доступны только a&?)

КОЛЬЦЕВОЙ СДВИГ ЧЕРЕЗ С c<X<c
КОЛЬЦЕВОЙ СДВИГ ЧЕРЕЗ С c>X>c
СДВИГ УМНОЖЕНИЕ НА 2	c<X<0
СДВИГ ЗНАКОВОЕ ДЕЛЕНИЕ НА 2 s>X>c
СДВИГ БЕЗЗНАКОВОЕ ДЕЛЕНИЕ НА 2 0>X>c
КОЛЬЦЕВОЙ СДВИГ ЧЕРЕЗ A a<X<a		( X только x или y)
КОЛЬЦЕВОЙ СДВИГ ЧЕРЕЗ A a>X>a		( X только x или y)

ВЫЗОВ ФУНКЦИИ CALL		call near X
ВЫЗОВ ФУНКЦИИ CALL		call X
ВЫЗОВ ФУНКЦИИ CALL		call far X
ВОЗВРАТ ИЗ ФУНКЦИИ		ret
ВОЗВРАТ ИЗ ФУНКЦИИ		ret far
ВОЗВРАТ ИЗ ПРЕРЫВАНИЯ	iret
ПЕРЕХОД БЕЗУСЛОВНЫЙ		go near X
ПЕРЕХОД БЕЗУСЛОВНЫЙ		go X
ПЕРЕХОД БЕЗУСЛОВНЫЙ		go far X
ПЕРЕХОД УСЛОВНЫЙ		if condition X
ПРОПУСК УСЛОВНЫЙ		skip X#Y=Z	(в avr)
ОСТАНОВ					halt
ОСТАНОВ С ОЖИДАНИЕМ СОБЫТИЯ wait
ОСТАНОВ С ОЖИДАНИЕМ ПРЕРЫВАНИЯ wait i
ПРОГРАММНОЕ ПРЕРЫВАНИЕ	trap
НИЧЕГО НЕ ДЕЛАНИЕ		nop 

Комбинированные операции - генерируют несколько команд:

ПЕРЕХОД УСЛОВНЫЙ		if чтото=0 X
ПЕРЕХОД УСЛОВНЫЙ		if чтото=0 X
ВСТАВКА НАТИВНОЙ КОМАНДЫ inline cmd X,Y (внутри inline строки только одна строка ассемблера, но в ней можно использовать препроцессор нативного ассемблера)

Режимы адресации:

НЕПОСРЕДСТВЕННЫЙ        12			12			число
РЕГИСТРОВЫЙ				r			r			имя регистра может быть a,cc,x,xl,xh,y,yl,yh,sp результат - значение регистра
ОТНОСИТЕЛЬНЫЙ			label    	label
ПРЯМОЙ					label		label		результат - значение переменной по адресу данной метки
ПОРТ ВВ					<port>		label		результат - значение переменной по адресу данной метки (это для avr)
ИНДЕКСНЫЙ				[r]			[r]			имя регистра может быть x,y,sp результат - значение переменной по адресу из регистра
ИНДЕКСНЫЙ				label[r]	[label+r]	имя регистра может быть x,y,sp результат - значение переменной по адресу label со смещением из r
НЕПРЯМОЙ				[label]		[label]					значение переменной из расположенной по адресу из ячейки памяти расположенной по адресу хранящейся в ячейке памяти
НЕПРЯМОЙ				[label[r]]	[[off]+r]			имя регистра может быть x,y,sp результат - значение переменной из расположенной по адресу из ячейки памяти расположенной по адресу label со смещением из r
ПОБИТОВЫЙ				label#bit	label#bit			результат - значение бита по адресу данной метки с номером bit
ПОБИТОВЫЙ К ПОРТУ ВВ	<port>#bit	label#bit			результат - значение бита по адресу данной метки с номером bit (для avr)

Метки:

МЕТКА С АДРЕСОМ			label@address:
МЕТКА					label:

Данные:

ПРИВЯЗАННЫЕ ПЕРЕМЕННЫЕ				(u8), (u16), (u32)
НЕИНИЦИАЛИЗИРОВАННЫЕ ПЕРЕМЕННЫЕ		(x8), (x16), (x32)						где x = {r,m} r - псевдорегистровая память, m - оперативная память
ИНИЦИАЛИЗИРОВАННЫЕ ЗНАЧЕНИЯ			(x8) val, (x16) val, (x32) val			где x = {f,e} f - флэш память, e - eeprom

ПРИВЯЗАННЫЕ МАССИВЫ				    (u8)[n], (u16)[n], (u32)[n]				n - размерность массива
НЕИНИЦИАЛИЗИРОВАННЫЕ ПЕРЕМЕННЫЕ		(x8)[n], (x16)[n], (x32)[n]				где x = {r,m} r - псевдорегистровая память, m - оперативная память, n - размерность массива
ИНИЦИАЛИЗИРОВАННЫЕ ЗНАЧЕНИЯ			(x8)[a,b,..], (x16)[a,b,..], (x32)[a,b,..] где x = {f,e} f - флэш память, e - eeprom, a,b,... - данные для инициализации массива

Препроцессор

ПОДКЛЮЧИТЬ ФАЙЛ			include filename{.ext}
ОПРЕДЕЛИТЬ КОНСТАНТУ	define const{ value}
ОПРЕДЕЛИТЬ МАКРОС		define name(parameter1{,parameter2...}) macros_body
В макросе можно использовать несколько строк:
	define a(b) a=b;\   // обязательно завершайте команды в обрезанных строках символом ';'
				b++;\
				c=a;
В макросе можно использовать локальные метки:
	define a(b) @1: b--; if z=0 @1;
УСЛОВНАЯ КОМПИЛЯЦИЯ		ifdef const
						...
						endif
						ifndef const
						...
						endif
Препроцессор примитивный, однопроходный и тупо подменяющий строки. Будьте осторожнее.
В именах констант и макросов можно использовать английские буквы, цифры и символ точки.

Особенности

Ассемблер экспериментальный, поэтому хотелось сделать программу-транслятор максимально простой и легко модифициуемой, поскольку
сам окончательный язык в начале не был ясен, а рождался по ходу написания транслятора. За простоту транслятора приходится платить.

При компиляции из всего кода удаляются все пробелы (исключения ниже). Это дает возможность вставлять пробелы для удобочитаемости внутрь переменных и даже чисел.
Например 'gpioa odr#0 = 1' и 'if z = 0 loop'. НО убираются абсолютно все пробелы, в том числе из строк инициализации данных! Решение:
line:	(f8)[3] {"тут"}
		(f8) {32}
		(f8)[6] {"строка"}
		(а8) {0}
Да, не элегантно, но так ли часто мы используем строки на крохотных контроллерах?
Обещанные исключения: нельзя разбавлять пробелами инструкции препроцессора - он работает до компилятора, до "сжатия" пробелов. И не жмутся пробелы при
вставке команд нативного ассемблера: inline elpm X; -> 'elpm X'
Еще одна неприятная неявность заключается в разбиении строк на "команды" по ';'. То есть строка (f8)[27]"бедная строка; ее разрежут", будет распилена на 
две непонятных команды '(f8)[27]"беднаястрока' и 'ееразрежут"'. Решение аналогично борьбе с пробелами.

Библиотеки макросов (stm8)

Сначала чуть чуть о stm8 после reset:

- тактировние от внутреннего генератора (hsi) с множителем 8 - частота fmaster = 2 МГц
- тактирование всех периферийных устройств включено
- прерывания глобально запрещены

Итак...

Системные, файл 'system'

Стэк
Stack.init(param)		- инициализирует указатель стека в значение 'param'

Прерывния (я обернул столь простые команды - i=0 и i=1 в макрос потому что интуитивно не понятно что 1 это запрет, а 0 разрешение)
Interrupt.disable		- общий запрет прерываний
Interrupt.enable		- общее разрешение прерываний 


Порты ввода-вывода, файл 'gpio'

Дам имена макросов для Gpioa - для остальных аналогично
Gpioa.output(pin)		- настроить ногу pin как выход
Gpioa.pushup(pin)		- подключить в pin резистор подтягивающий ногу к питанию
Gpioa.float(pin)		- отключить в pin резистор подтягивающий ногу к питанию
Gpioa.fast(pin)			- включить в pin режим при котором скорость реакции выше но и потребление выше
Gpioa.slow(pin)			- включить в pin режим при котором скорость реакции ниже но и потребление меньше
Gpioa.set(pin)			- выставить на ноге pin значение "1"
Gpioa.clr(pin)			- выставить на ноге pin значение "0"
Gpioa.invert(pin)		- инверсия значения на ноге pin
Gpioa.setvalue(value)	- присвоить порту значение

Gpioa.input(pin)		- настроить ногу pin как вход
Gpioa.interrupt(pin)	- разрешить прерывания по ноге pin
Gpioa.disableinterrupt(pin)	- запретить прерывания по ноге pin
Gpioa.getvalue  		- прочитать значение из порта
Gpioa.get(pin)			- прочитать значение на ноге pin


Тактирование периферийных устройств, файл 'power'

Power.on.all			- включить тактирование всех устройств
Power.off.all			- выключить тактирование всех устройств

Power.on.имяустройства	- включить тактирование устройства с указанным именем
Power.off.имяустройства	- выключить тактирование устройства с указанным именем

Допустимые имена устройств: tim1,tim2,tim3,tim4,uart1,uart2,spi,i2c,awu,adc

Запись в EEPROM и FLASH, файл 'flash'

Flash.unprotect			- разрешить запись в область flash
Flash.protect			- запретить запись во flash
Eeprom.unprotect		- разрешить запись в область eeprom
Eeprom.protect			- запретить запись во eeprom


Последовательные порты uart, простой обмен без буферизации, файлы 'uart1', 'uart2'

Оба uart есть только в 20х серии stm8s в более младших есть либо uart1 либо uart2. Чтобы улучшить переносимость кода, между младшими
контроллерами вместо Uart{X} можно использовать префикс Serial. Serial автоматически заменяется на имеющийся в данном контроллере uart.
В контроллерах 20x серии Serial - псевдоним uart с младшим номером из имеющихся. Макросы даю для Uart1, для Uart2 они такие-же.
Это простая небуферизированная передача без прерываний и т.п.

Uart1.init(fmaster,speed)	- инициализация uart
Uart1.putc				- послать байт находящийся в регистре 'a'
Uart1.puts(s)			- послать 0-терминированную строку лежащую по адресу s 
Uart1.getc				- принять байт, положить его в регистр 'a'

Кроме скорости надо дополнительно инициализировать "ноги", а они для разных контроллеров могут быть разными
поэтому это надо сделать отдельн7ой командой

Uart.atD5D6
Uart.atA4A5

//todo Последовательные порты uart, обмен по прерываниям с буферизацией, файлы 'uart1buf', 'uart2buf'

Оба uart есть только в 20х серии stm8s в более младших есть либо uart1 либо uart2. Чтобы улучшить переносимость кода, между младшими
контроллерами вместо Uart{X} можно использовать префикс Serial. Serial автоматически заменяется на имеющийся в данном контроллере uart.
В контроллерах 20x серии Serial - псевдоним uart с младшим номером из имеющихся. Макросы даю для Uart1, для Uart2 они такие-же.
Размер всех буферов менее 255 байт.

Uart1.init(fmaster,speed,rb,tb)	- инициализация uart, rb - размер буфера приема в байтах, tb  соответственно буфера передачи.
Uart1.putc(c)			- послать байт c
Uart1.puts(s)			- послать 0-терминированную строку лежащую по адресу s 
Uart1.getc				- принять байт, положить его в регистр 'a'


//todo
Последовательный порт spi, простой обмен без буферизации, файл 'spi'

Spi.init
Spi.go					- отправляет байт из регистра 'a' а полученный байт кладет опять в 'a'

//todo
Последовательный порт i2c, простой обмен как мастер без буферизации, файл 'i2c'

I2c.init
I2c.start(addr)
I2c.send(byte)
I2c.receive
I2c.stop

Продолжение следует